## Android Binder

- 参考网址

  - https://zhuanlan.zhihu.com/p/35519585
  - https://blog.csdn.net/boyupeng/article/details/47011383

- Binder

  - 性能

    用户空间->内核空间->用户空间。Linux使用copy_from_user()和copy_to_user()实现这两个跨空间拷贝

  - 稳定性

  - 安全性

- Binder 一次拷贝

  - Binder驱动

    驱动为接收方分担了最为繁琐的任务：分配/释放大小不等，难以预测的有效负荷缓存区，而接收方只需要提供缓存来存放大小固定，最大空间可以预测的消息头即可

  - 复制一次

    mmap()把接收方的**内存映射**到驱动，发送方数据拷贝到驱动中映射的内存，实现了发送方到接收方只复制一次

- **Binder 接收线程管理**

- **数据包接收队列与（线程）等待队列管理**

  - 同步请求
    - Client端，等待返回包的线程必须是发送请求的线程，而不能由一个线程发送请求包，另一个线程等待接收包，否则将收不到返回包；
    - Server端，发送对应返回数据包的线程必须是收到请求数据包的线程，否则返回的数据包将无法送交发送请求的线程。
    - 同步调用会阻塞等待返回结果
  - 异步请求
    - 异步交互做了限流，令其为同步交互让路
      - 对于某个Binder实体，只要有一个异步交互没有处理完毕，例如正在被某个线程处理或还在任意一条to-do队列中排队，那么接下来发给该实体的异步交互包将不再投递到to-do队列中，而是阻塞在驱动为该实体开辟的异步交互接收队列（Binder节点的async_todo域）中，但这期间同步交互依旧不受限制直接进入to-do队列获得处理。一直到该异步交互处理完毕下一个异步交互方可以脱离异步交互队列进入to-do队列中。之所以要这么做是因为同步交互的请求端需要等待返回包，必须迅速处理完毕以免影响请求端的响应速度，而异步交互属于‘发射后不管’，稍微延时一点不会阻塞其它线程。所以用专门队列将过多的异步交互暂存起来，以免突发大量异步交互挤占Server端的处理能力或耗尽线程池里的线程，进而阻塞同步交互。

