

- **性能优化**
  - 好应用定义
    - 业务/功能
    - 符合逻辑的交互
    - 优秀的性能
- **性能优化四个方面**
  - 流畅
    - 使用时避免出现卡顿，响应速度快，减少用户等待的时间，满足用户期望。
  - 稳定
    - 减低 crash 率和 ANR 率，不要在用户使用过程中崩溃和无响应。
  - 省电、省流量
    - 节省流量和耗电，减少用户使用成本，避免使用时导致手机发烫。
  - 安装包小
    - 安装包小可以降低用户的安装成本。

- **卡顿优化**

  - 卡顿场景
    - UI：绘制，刷新
    - 启动：安装启动，冷启动，热启动
    - 跳转：页面间切换 前后台切换
    - 响应：按键，系统事件，滑动
  - 4种卡顿场景的根本原因可以分为两大类：
    - 界面绘制。主要原因是绘制的层级深、页面复杂、刷新不合理，由于这些原因导致卡顿的场景更多出现在UI和启动后的初始界面以及跳转到页面的绘制上。
    - 数据处理。导致这种卡顿场景的原因是数据处理量太大，一般分为三种情况，一是数据在处理UI线程，二是数据处理占用CPU高，导致主线程拿不到时间片，三是内存增加导致GC频繁，从而引起卡顿。

- **Android系统显示原理**

  Android应用程序把经过测量、布局、绘制后的Surface缓存数据，通过SurfaceFlinger把数据渲染到显示屏幕上， 通过Android的刷新机制来刷新数据。也就是说应用层负责绘制，系统层负责渲染，通过进程间通信把应用层需要绘制的数据传递到系统层服务，系统层服务通过刷新机制把数据更新到屏幕上。

  - 绘制核心：Measure，Layout，Draw
    - ViewRootImp类的performTraversals() 方法开始执行，Measure和Layout都是通过递归来获取View的大小和位置，并且以深度作为优先级，可以看出层级越深、元素越多、耗时也就越长
  - SharedClient
    - 31SharedBufferStack,就是window
  - FPS:每秒传递的帧数,系统每隔16ms发出VSYNC信号

- **卡顿根本原因**

  - 绘制任务太重，绘制一帧内容耗时太长。
  - 主线程太忙，根据系统传递过来的VSYNC信号来时还没准备好数据导致丢帧。
  - 主线程工作
    - UI生命周期控制
    - 系统事件处理
    - 消息处理
    - 界面布局
    - 界面绘制
    - 界面刷新

- **性能分析工具**

  - Profile GPU Rendering
    - 开发者模式下，反应当前绘制的耗时，提供一个标准的耗时，如果高于标准耗时，就表示当前这一帧丢失
  - Layout层次的Hierarchy View
  - 静态代码检查工具Lint
  - TraceView：用来分析函数调用过程，分析到每一个方法的执行时间，其中可以统计出该方法调用次数和递归次数，实际时长等参数维度，使用非常直观，分析性能非常方便
  - Systrace UI 性能分析

- **优化建议**

  - 布局优化
    - 减少层级。合理使用RelativeLayout和LinerLayout，合理使用Merge。
    - 提高显示速度。使用ViewStub，它是一个看不见的、不占布局位置、占用资源非常小的视图对象。
    - 布局复用。可以通过标签来提高复用。
    - 尽可能少用wrap_content。wrap_content 会增加布局measure时计算成本，在已知宽高为固定值时，不用wrap_content 。
    - 删除控件中无用的属性。
  - 避免过度绘制
    - 布局上的优化。移除XML中非必须的背景，移除Window默认的背景、按需显示占位背景图片
    - 自定义View优化。使用 canvas.clipRect()来帮助系统识别那些可见的区域，只有在这个区域内才会被绘制。
  - 启动优化
    - UI布局。应用一般都有闪屏页，优化闪屏页的UI布局，可以通过Profile GPU Rendering检测丢帧情况。
    - 启动加载逻辑优化。可以采用分布加载、异步加载、延期加载策略来提高应用启动速度。
    - 数据准备。数据初始化分析，加载数据可以考虑用线程初始化等策略。
  - 合理的刷新机制
    - 尽量减少刷新次数
    - 尽量避免后台有高的CPU线程运行。
    - 缩小刷新区域。
  - 其他
    - 在实现动画效果时，需要根据不同场景选择合适的动画框架来实现。有些情况下，可以用硬件加速方式来提供流畅度。

- **内存优化**
- **Android内存管理机制**
  - Java对象生命周期
    - 创建阶段->应用阶段->不可见阶段->不可达阶段->收集阶段->终结阶段->对象空间重新分配阶段
  - 内存分配
    - 内存分配实际上是对堆的分配和释放。Heap Size最大限制阈值
  - 内存回收机制
    - Young Generation(年轻代)、Old Generation(年老代)、Permanent Generation(持久代)。最近分配的对象会存放在Young Generation区域。对象在某个时机触发GC回收垃圾，而没有回收的就根据不同规则，有可能被移动到Old Generation，最后累积一定时间在移动到Permanent Generation 区域GC会增加应用的卡顿情况，影响应用的流畅性，因此需要尽量减少系统GC行为
- **内存分析工具**
  - Memory Monitor
    - 显示可用和已用内存，并且以时间为维度实时反应内存分配和回收情况。
    - 快速判断应用程序的运行缓慢是否由于过度的内存回收导致。
    - 快速判断应用是否由于内存不足导致程序崩溃。
  - Heap Viewer
    - 查看不同数据类型在内存中的使用情况，可以看到当前进程中的Heap Size的情况，分别有哪些类型的数据，以及各种类型数据占比情况。通过分析这些数据来找到大的内存对象，再进一步分析这些大对象，进而通过优化减少内存开销，也可以通过数据的变化发现内存泄漏。
  - Allocation Tracker 
    - 分配跟踪记录应用程序的内存分配，并列出了它们的调用堆栈，可以查看所有对象内存分配的周期。
  - Memory Analyzer Tool(MAT)
    - 一个快速，功能丰富的Java Heap分析工具，通过分析Java进程的内存快照HPROF分析，从众多的对象中分析，快速计算出在内存中对象占用的大小，查看哪些对象不能被垃圾收集器回收，并可以通过视图直观地查看可能造成这种结果的对象。

- **常见内存泄漏场景**
- **优化内存空间**
  - 对象引用。强引用、软引用、弱引用、虚引用四种引用类型，根据业务需求合理使用不同，选择不同的引用类型。
  - 减少不必要的内存开销。注意自动装箱，增加内存复用，比如有效利用系统自带的资源、视图复用、对象池、Bitmap对象的复用。
  - 使用最优的数据类型。比如针对数据类容器结构，可以使用ArrayMap数据结构，避免使用枚举类型，使用缓存Lrucache等等
  - 图片内存优化。可以设置位图规格，根据采样因子做压缩，用一些图片缓存方式对图片进行管理等等
- **稳定性优化**
  - Crash和ANR
    - 提高代码质量。比如开发期间的代码审核，看些代码设计逻辑，业务合理性等。
    - 代码静态扫描工具。常见工具有Android Lint、Findbugs、Checkstyle、PMD等等。
    - Crash监控。把一些崩溃的信息，异常信息及时地记录下来，以便后续分析解决。
    - Crash上传机制。在Crash后，尽量先保存日志到本地，然后等下一次网络正常时再上传日志信息。

- **耗电优化**
  - Battery Historian是一款由Google提供的Android系统电量分析工具，和Systrace一样，是一款图形化数据分析工具，直观地展示出手机的电量消耗过程，通过输入电量分析文件，显示消耗情况，最后提供一些可供参考电量优化的方法。
  - 计算优化，避开浮点运算等
  - 避免WaleLock使用不当。
  - 使用Job Scheduler。
- **安装包大小优化**
  - 代码混淆。使用ProGuard代码混淆器工具，它包括压缩、优化、混淆等功能。
  - 资源优化。比如使用Android Lint删除冗余资源，资源文件最少化等
  - 图片优化。比如利用AAPT工具对PNG格式的图片做压缩处理，降低图片色彩位数等。
  - 避免重复功能的库，使用WebP图片格式等。
  - 插件化。比如功能模块放在服务器上，按需下载，可以减少安装包大小。
- 小结
  - 

