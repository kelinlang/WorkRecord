## C++ Primer 知识要点

- C++的类型转换
  - 隐式转换
    - 整形的隐式转换：多数表达式中，比 int 小的整形首先提升为较大整形
    - 数组转成指针
    - 指针的转换： 0,nullptr 转成任意指针，任意指针转 void
    - 转换时机：
      - 拷贝初始化  
      - 算术或关系运算  
      - 函数调用时  
  - 显示转换
    - 命名强制类型转换 cast-name<type>(expression)
      - static_cast：只要不包含底层 const，都可以使用。适合将较大算术类型转换成较小算术类型
      - const_cast： 只能改变底层 const，例如指向 const 的指针(指向的对象不一定是常量，但是无法
        通过指针修改)，如果指向的对象是常量，则这种转换在修改对象时，结果未定义。  
      - reinterpret_cast：通常为算术对象的位模式提供较低层次上的重新解释。如将 int*转换成 char*。
        很危险！  
      - dynamic_cast：一种动态类型识别。转换的目标类型，即 type，是指针或者左右值引用，主要
        用于基类指针转换成派生类类型的指针(或引用)，通常需要知道转换源和转换目标的类型。如
        果转换失败，返回 0（转换目标类型为指针类型时）或抛出 bad_cast 异常（转换目标类型为引
        用类型时）  
    - 旧式强制类型转换 type (expr) 或 (type) expr  
      - 旧式强制类型转换与 const_cast， static_cast， reinterpret_cast 拥有相似行为，如果换成 const_cast， static_cast 也合法，则其行为与对应命名转
        换一致。不合法，则执行与 reinterpret_cast 类似的行为  
      - 

- **初始化与赋值** 

  C++中初始化和赋值是 2 个完全不同的操作  

  - 显示初始化：创建变量时的赋值行为  
    - 拷贝初始化： int a = 0;  
    - 直接初始化： int a(0);  
    - 初始值列表： int a = {0}; 或 int a{0};  
  - 默认初始化（程序）  
    - 局部变量  
      - non-static：内置类型非静态局部变量不会执行默认初始化  
      - static：如果没有初始值则使用值初始化。  
    - 全局变量：内置类型全局变量初始化为 0。  
  - 值初始化  
    - 内置类型的值初始化为 0  
    - container<T> c(n) 只指定了容器的大小，未指定初始值，此时容器内的元素进行值初始化  
    - 使用初始值列表时，未提供的元素会进行值初始化  
    - 静态局部变量会使用值初始化  

- **声明与定义**  

  声明不会分配存储空间，定义会分配存储空间  

- 作用域  

  - 访问被同名局部变量覆盖的全局变量： ::变量名（不管有多少层覆盖，都是访问全局）  

- **复合类型**  

  - 引用  
    
    - 本质：引用并非对象， 别名，未分配空间。  
    - 形式： int &a = b; 
    - 理解和使用
      - ​	非常量引用不能绑定到字面值或表达式的计算结果 
      - 一般来说， 引用类型和绑定的对象类型需严格匹配  
      - 程序把引用和其初始值绑定到一起（对引用的操作都在其绑定的对象上进行）因此一旦初始化完成，无法另引用重新绑定到另外一个对象。因此必须初始化  
      - 引用本身并非对象，故不能定义引用的引用  
    
  - 指针  
  
    - 指针不同与引用， 指针本身就是一个对象  
    - 因为引用不是对象，没有实际地址，所以不能定义指向引用的指针  
    - 指针是一个对象，所以存在对指针的引用  
    - 一般来说， 指针类型和指向的对象类型也需严格匹配  
    - 编译器并不负责检查试图拷贝或以其它方式访问无效指针  
    - 和试图使用未经初始化的变量一样，使用未经无效指针的后果无法估计  
    - 空指针：不指向任何对象（不要混淆空指针和空类型(void)的指针）  
      - int *p1 = nullptr; (C++11)  
      - int *p2 = 0;  
      - int *p3 = NULL; //#include cstdlib  
    - 空类型(void)指针用于存放任意对象的地址  
  
  - 复合类型的声明  
  
    - 非数组与复合类型的声明  
  
    - 数组与复合类型的复杂申明  
  
      从数组名字开始，由内到外分析（数组的维度紧跟着被声明的名字 ）  
  
      - 数组与指针的复杂申明 c++ int (*Parray)[10] = &arr; //Parry 是一个指针，指向一个含有 10
        个 int 的数组  
      - 数组与引用的复杂申明 c++ int (&arrRef)[10] = arr; //arrRef 是一个引用，引用一个含有 10
        个 int 的数组  
      - 数组与指针及引用的混合复杂申明 c++ int *(&arry)[10] = ptrs; //arry 是一个引用，引用一
        个包含 10 个 int 指针的数组  
  
- const  

  - const 对象  
    - const 对象必须初始化，  
    - 只能在 const 类型的对象上执行不改变其内容的操作  
    - 当以编译时初始化的方式定义一个 const 对象时，编译器将在编译过程中把用到该对象的地方替换成对应值  
    - 默认状态下， const 对象仅在文件内有效。多个文件的同名 const 对象等同于在不同文件中定义了独立的变量  
    - 要在多个文件之间共享同一个 const 对象，需在定义和声明时都加上 extern  
  - const 的引用（常量引用）
    - 不能修改所绑定的对象    
    - 和非常量引用不同， 常量引用可以使用字面值或任意表达式作为初始值（原因:绑定了一个临时量常量）  
  - 指针与 const  
    - 所指地址内容不可修改的指针(并不一定要指向常量，只是为了说明无法修改所指的对象) c++ const
      int *a = &b;  
    - const 指针(常量指针)：不能修改指针，将一直指向一个地址，因此必须初始化。但是指向的对象不是常量的话，可以修改指向的对象  
  - 顶层 const 与底层 const  
    - 顶层 const：无法修改指针本身（顶层是一种直接的关系） c++
      const int ci = 123; int *const a = &b;  
    - 底层 const：无法修改所指的对象（底层是一种间接的关系）  
      - 用于声明引用的 const 都是底层 const  

- **constexpr 与常量表达式**  

  - 常量表达式：在“编译过程”就能确定结果的表达式  

    - 字面值  
    - 常量表达式初始化的 const 对象  

  - constexpr 变量(C++11)：

    - 变量声明为 contexpr 类型，编译器会检查变量的值是否是个常量表达式

  - constexpr 函数：这种函数足够简单以使编译时就可以计算其结果。  

  - 字面值类型：能使用 constexpr 声明的类型应该足够简单，称为字面值类型  

    - 算数类型  

    - 引用 & 指针  

      constexpr 的指针初始值必须是 nullptr， 0 或存储于某个固定地址中的对象
      一般来说全局变量和静态局部变量的地址不变
      constexpr 指针， constexpr 只对指针有效，与指针所指对象无关
      constexpr const int *p = &i //p 是常量指针，指向整形常量 i  

    - 不包括

      - 自定义类型  
      - I/O 库  
      - string 字符串  

- 类型别名  

  - typedef： typedef double wages;  

  - using（C++11)： using SI = Sales_item;

    const 与指针的类型别名使用时，还原别名来理解 const 的限定是错误的

- auto  

  - 编译器根据初始值判断变量类型  
  - 必须初始化  
  - 初始值为引用时，类型为所引对象的类型  
  - auto 一般会忽略掉顶层 const，底层 const 会保留下来  
  - 如果希望判断出的 auto 是一个顶层 const， 使用 const auto。  
  - 还可以将引用的类型设为 auto，此时原来的初始化规则仍然适用  

- decltype  

  希望根据表达式判定变量类型，但不用表达式的值初始化变量  

  decltype(f()) sum = x; f()并不会被调用， sum 为 f()的返回类型
  引用从来都作为其所指对象的同义词出现，只有在 decltype 处是一个例外  

  - 如果表达式的结果对象能作为一条赋值语句的左值，则表达式将向 decltype 返回一个引用类型
    - decltype(*p) c; //错误， c 是 int &，必须初始化  
  - 变量加上括号后会被编译器视为一个表达式    
    - decltype((i)) d; //错误， d 是 int &，必须初始化  



### 2 模板与泛型编程  

- 模板函数  

  当调用一个函数模板时，编译器(通常)用函数实参来为我们推断模板实参。编译器用推断出的模板参数为我们
  实例化一个特定版本的函数，这些编译器生成的版本通常被称为模板的实例  

  上面的模板函数说明了编写泛型代码的两个重要原则：  

  - 模板中的函数参数是 const 的引用（保证了函数可以用于不能拷贝的类型。同时，如果 compare 用于处
    理大对象，这种设计策略还能使函数运行得更快）  
  - 函数体中的条件判断仅使用<比较运算（如果编写代码时只使用<运算符，就降低了 compare 函数对要处
    理的类型的要求。 这种类型必须支持<，但不必支持>。实际上， 如果真的涉及类型无关和可移植性，应
    该用 less，因为<无法比较指针，但是 less 可以）  

  函数模板可以声明为 inline 或 constexpr 的，如同非模板函数一样。 inline或 constexpr 说明符放在模板参数列表之后，返回类型之前。  

  - 模板参数  

    - 在模板定义中， 模板参数列表不能为空  
    - 模板参数的名字没有什么内在含义，通常将类型参数命名为 T，但实际上可以使用任何名字  
    - 一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。模板参数会隐藏外层作用域中声明的相同名字，模板内不能重用模板参数名  
    - 函数参数相同，声明中的模板参数的名字不必与定义中相同；  
    - typename 和 class 并没有什么不同， typename 可能更直观，因为 class 可能会让人觉得能使用的类型必须是类类型  

    模板类型参数  

    - 用来指定返回类型或函数类型，以及在函数体内用于变量声明或类型转换  

    非类型模板参数  

    - 整形：绑定到非类型整形参数的实参必须是一个常量表达式  
    - 指针或引用：绑定到指针或引用非类型参数的实参必须具有静态的生存期，不能用一个普通局部变量或动态对象作为指针或引用非类型模板参数的实参。 指针也可以用 nullptr 或一个值为 0 的常量表达式来实例化  

  - 函数形参  
  
    - 普通类的成员模板  
    - 类模板的成员模板  
      - 当在类外定义成员模板时，必须同时为类模板和成员模板提供模板参数  
  
- **类模板**  

  template <typename T> class Blob {
  //typename 告诉编译器 size_type 是一个类型而不是一个对象
  typedef typename std::vector<T>::size_type size_type
  //...
  };  

  - 与模板函数的区别  

    - 编译器不能为类模板推断模板参数类型  
    - 使用时必须在模板名后的尖括号中提供额外信息  

  - 模板类名的使用  

    - 类外使用需要指明  
    - 类内使用不需要指明  

  - 类模板的成员函数  

  - 类型成员  

  - 类模板和友元  

    - 普通类中将另一模板类声明为友元  
    - 模板类中将另一模板类声明为友元  
      - 为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数（上面的 X）  
    - 令模板自己的类型参数成为友元  

  - 模板类型别名  

    - 类模板的一个实例化定义一个类类型：typedef Blob<string> StrBlob;  

    - using为类模板定义一个类型别名

      - template <typename T> using twin = pair<T,T>;
        twin<string> authors; //authors 是一个 pair<string,string>；  

      - 定义一个模板类型别名时，可以固定一个或多个模板参数；
        template <typename T> using partNo = pair<T,unsigned>；
        partNo<string> books; //pair<string,unsigned>；  

  - 类模板的 static 成员  

    - static 属于每个实例化的类类型，而不是类模板。即，每个实例化的类都有一个自己对应的 static 成员  
    - 模板类的每个 static 成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 static 对象  

- 模板编译  

  - 遇到模板时不生成代码，实例化时生成代码  
  - 函数模板和类模板成员函数的定义通常放在头文件中  
  - 实例化冗余：当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。
    当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有
    该模板的一个实例  

- 模板参数  

  - 默认模板实参  

    - 模板函数
      template <typename T,typename F = less<T>>
      int compare(const T &v1,const T &v2,F f = F( ))
      {
      if(f(v1,v2)) return -1;
      if(f(v2,v1)) return 1;
      return 0;
      }
      和函数默认实参一样，所有提供了默认实参的形参右边的形参都需要提供默认实参  

    - 类模板  

      template <class T = int> class Numbers   

      Numbers<> av;//表示使用默认类型

  - 4.2 模板实参推断
  
    - 函数模板的参数转换  
  
      - 模板类型参数的类型转换：将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 const转换及数组或函数到指针的转换  
        - 实参会被拷贝
        - 对于一个引用参数来说，转换为 const 是允许的，因此合法；  
      - 非引用类型形参可以对数组或函数指针应用正常的指针转换  
      - 普通类型参数的类型转换：模板函数可以有用普通类型定义的参数
        这种函数实参不进行特殊处理，这些实参执行正常类型的转换  
  
    - 显示实参  
  
      - 显示实参配对顺序：由左至右。只有尾部参数的显示模板实参可以忽略，但必须能推断出来  
  
    - 尾置返回类型与 traits  
  
      template <typename It>
      auto fcn(It beg,It end) -> decltype(*beg)
      {
      //处理序列
      return *beg;//返回序列中一个元素的引用
      }  
  
    - 函数指针和实参推断  
  
    - 引用与实参推断  
  
      - 非常重要的是记住两个规则：  
        - 编译器会应用正常的引用绑定规则；  
        - const 是底层的，不是顶层的；
  
      当一个函数的参数是模板类型参数的一个普通(左值)引用时，绑定规则告诉我们，只能传递给它一个左值：
  
    - 重载与模板  
  
    - 可变参数模板  
  
    - 模板特例化  



### 3 内存管理  

- new 和 delete  

### 4 智能指针  

- 
- 如何选择智能指针  
  - 如果程序要使用多个指向同一个对象的指针，应选择 shared_ptr。这样的情况包括：
    \- 有一个指针数组，并使用一些辅助指针来标示特定的元素，如最大的元素和最小的元素；
    \- 两个对象包含都指向第三个对象的指针；
    \- STL 容器包含指针。很多 STL 算法都支持复制和赋值操作，这些操作可用于 shared_ptr，但不能用于  
  - 如果程序不需要多个指向同一个对象的指针，则可使用 unique_ptr。如果函数使用 new 分配内存，
    并返还指向该内存的指针，将其返回类型声明为 unique_ptr 是不错的选择。这样，所有权转让给接受返回值的 unique_ptr，而该智能指针将负责调用 delete。 可将 unique_ptr 存储到 STL 容器在那个，只要不调用将一个 unique_ptr 复制或赋给另一个算法（如 sort()）   