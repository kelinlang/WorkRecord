





## 第2章 Java内存区域与内存溢出异常  

- **运行时数据区域**  

  - **程序计数器**  ：当前线程所执行的字节码的行号指示器，线程私有内存

  - **Java虚拟机栈** ：线程私有的，它的生命周期与线程相同

    每个方法被执行的时候， Java虚拟机都会同步创建一个栈帧[1]（Stack Frame） 用于存储局部变量表、 操作数栈、 动态连接、 方法出口等信息。 每一个方法被调用直至执行完毕的过程， 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。  

    - 如果线程请求的栈深度大于虚拟机所允许的深度， 将抛出StackOverflowError异常  
    -   如果Java虚拟机栈容量可以动态扩展[2]， 当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常  

  - **本地方法栈**  ：为虚拟机使用到的本地（Native）方法服务  

    - 与虚拟机栈一样， 本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常  

  - **Java堆**  

    - 分代回收：
    - 通过参数-Xmx和-Xms设定设置堆大小
    - 如果在Java堆中没有内存完成实例分配， 并且堆也无法再扩展时， Java虚拟机将会抛出OutOfMemoryError异常  

  - **方法区 ：**

    ​	 用于存储已被虚拟机加载的类型信息、 常量、 静态变量、 即时编译器编译后的代码缓存等数据  

    - 这区域的内存回收目标主要是针对常量池的回收和对类型的卸载  

  - **运行时常量池**  

    ​		方法区的一部分 ， Class文件中除了有类的版本、 字段、 方法、 接口等描述信息外， 还有一项信息是常量池表（Constant Pool Table） ， 用于存放编译期生成的各种字面量与符号引用， 这部分内容将在类加载后存放到方法区的运行时常量池中。  

    - 既然运行时常量池是方法区的一部分， 自然受到方法区内存的限制， 当常量池无法再申请到内存
      时会抛出OutOfMemoryError异常  

  - **直接内存**  

    ​		直接内存（Direct Memory） 并不是虚拟机运行时数据区的一部分， 也不是《Java虚拟机规范》 中
    定义的内存区域。 但是这部分内存也被频繁地使用， 而且也可能导致OutOfMemoryError异常出现  

    - NIO（New Input/Output） 类  

      ​		引入了一种基于通道（Channel） 与缓冲区（Buffer） 的I/O方式， 它可以使用Native函数库直接分配堆外内存， 然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。 这样能在一些场景中显著提高性能， 因为避免了在Java堆和Native堆中来回复制数据  

- **HotSpot虚拟机对象探秘**  

  - 对象的创建  

    - new 内部流程
      - 定位类的符号引用 ，并且检查这个符号引用代表的类是否已被加载、 解析和初始化过  ，如果没有就需要执行相应的类加载过程 
      - 为新生对象分配内存：java堆中划分出制定大小的内存
        - 多线程分配对象同步
        - 本地线程分配缓存
      - 初始化零值
      - 必要的设置
        - 如对象头：对象属于哪个实例，元数据信息，对象的哈希吗
      - 执行构造函数

  - 对象的内存布局

    - 对象在堆内存中的存储布局
      - 对象头
        - 两类信息  
          - 第一类是用于存储对象自身的运行时数据， 如哈
            希码（HashCode） 、 GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、 偏向时间戳等  
          - 类型指针 ：对象指向它的类型元数据的指针  
      - 实例数据
      - 对齐填充

  - 对象的访问定位  

    - 句柄访问
    - 直接指针访问

  - **实战： OutOfMemoryError异常**    

    - java堆溢出

      - 常规处理方法：内存映像分析工具（Eclipse MemoryAnalyzer  ）  ，确认内存泄漏（Memory Leak） 还是内存溢出（Memory
        Overflow）   

        - **内存泄漏**  

          ​		可进一步通过工具查看泄漏对象到GC Roots的引用链， 找到泄漏对象是通过怎
          样的引用路径、 与哪些GC Roots相关联， 才导致垃圾收集器无法回收它们， 根据泄漏对象的类型信息以及它到GC Roots引用链的信息， 一般可以比较准确地定位到这些对象创建的位置， 进而找出产生内存泄漏的代码的具体位置。  

        - **内存溢出**

          ​		再从代码上检查是否存在某些对象生命周期过长、 持有状态时间过长、 存储结构设计不合理等情况， 尽量减少程序运行期的内存消耗  

    - 虚拟机栈和本地方法栈溢出  

      - StackOverflowError异常  
      - OutOfMemoryError异常  

- **垃圾收集器与内存分配策略**  GC

  ​		当需要排查各种内存溢出、 内存泄漏问题时， 当垃圾收集成为系统达到更高并发量的瓶颈时， 我们就必须对这些“自动化”的技术实施必要的监控和调节。  

  - 可达性分析算法

    ​	从GC Roots开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”（Reference Chain）  如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GC Roots到这个对象不可达时， 则证明此对象是不可能再被使用的。  

    - GC Roots对象
      - 在虚拟机栈（栈帧中的本地变量表） 中引用的对象， 譬如各个线程被调用的方法堆栈中使用到的参数、 局部变量、 临时变量等。  
      - 在方法区中类静态属性引用的对象， 譬如Java类的引用类型静态变量。  
      - 在方法区中常量引用的对象， 譬如字符串常量池（String Table） 里的引用  
      - 在本地方法栈中JNI（即通常所说的Native方法） 引用的对象。  
      - Java虚拟机内部的引用， 如基本数据类型对应的Class对象， 一些常驻的异常对象（比如
        NullPointExcepiton、 OutOfMemoryError） 等， 还有系统类加载器  
      - 所有被同步锁（synchronized关键字） 持有的对象。  
      - 反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、 本地代码缓存等  
      - 其他对象“临时性”地加入  

  - 再谈引用  

    - 四大应用：引用强度依次逐渐减弱  
      - 强引用（Strongly Re-ference）  
        - 无论任何情况下， 只要强引用关系还存在， 垃圾收集器就永远不会回收掉被引用的对象。  
      - 软引用（Soft Reference）  
        - 发生内存溢出异常前，进行二次回收，如果这次回收还没有足够内存才会抛出内存溢出异常
      - 弱引用（Weak Reference）  
        - 被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 当垃圾收集器开始工作， 无论当前内存是否足够， 都会回收掉只被弱引用关联的对象。   
      - 虚引用（Phantom Reference）
        - 一个对象是否有虚引用的存在， 完全不会对其生存时间构成影响， 也无法通过虚引用来取得一个对象实例。 为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。      

  - 生存还是死亡

  - 回收方法区

  - **垃圾收集算法**

    - 分代收集理论
      - 假说
        - 弱分代假说（Weak Generational Hypothesis） ： 绝大多数对象都是朝生夕灭的。  
        - 强分代假说（Strong Generational Hypothesis） ： 熬过越多次垃圾收集过程的对象就越难以消
          亡。  
        - 跨代引用假说（ Intergenerational Reference Hypothesis） ： 跨代引用相对于同代引用来说仅占极少数。  
      - 部分收集（ Partial GC） ： 指目标不是完整收集整个Java堆的垃圾收集，   
        - 新生代收集（ Minor GC/Young GC） ： 指目标只是新生代的垃圾收集。  
        - 老年代收集（ Major GC/Old GC） ： 指目标只是老年代的垃圾收集。   
        - 混合收集（ Mixed GC） ： 指目标是收集整个新生代以及部分老年代的垃圾收集。   
      - 整堆收集（ Full GC） ： 收集整个Java堆和方法区的垃圾收集  
    - **标记-清除算法**  
      - 概念
        - 首先标记出所有需要回收的对象， 在标记完成后， 统一回收掉所有被标记的对象  
      - 缺点
        - 执行效率不稳定
        - 内存空间碎片化问题
    - **标记-复制算法**
      - 概念
        - 它将可用内存按容量划分为大小相等的两块， 每次只使用其中的一块。 当这一块的内存用完了， 就将还存活着的对象复制到另外一块上面， 然后再把已使用过的内存空间一次清理掉。  
      - 缺点
        - 浪费空间
    - **标记-整理算法**：所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内
      存  
      - 概念
        - 其中的标记过程仍然与“标记-清除”算法一样， 但后续步骤不是直接对可回收对象进行清理， 而是让所有存活的对象都向内存空间一端移动， 然后直接清理掉边界以外的内存  

    综合：另外， 还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担， 做法是让虚
    拟机平时多数时间都采用标记-清除算法， 暂时容忍内存碎片的存在， 直到内存空间的碎片化程度已经
    大到影响对象分配时， 再采用标记-整理算法收集一次， 以获得规整的内存空间。  

  - HotSpot的算法细节实现  

  - 经典垃圾收集器

  - 低延迟垃圾收集器  

    - **性能指标**
      - 内存占用
      - 吞吐量
      - 低延迟：最重要的性能指标

  - 选择合适的垃圾收集器  

    - 收集器的权衡  
    - 虚拟机及垃圾收集器日志  
    - 垃圾收集器参数总结  

  - 实战： 内存分配与回收策略  

- **虚拟机性能监控、 故障处理工具**  

  - 概述

    - 给一个系统定位问题的时候， 知识、 经验是关键基础， 数据是依据， 工具是运用知识处理数据的
      手段。 这里说的数据包括但不限于异常堆栈、 虚拟机运行日志、 垃圾收集器日志、 线程快照
      （threaddump/javacore文件） 、 堆转储快照（heapdump/hprof文件） 等。  

  - 基础故障处理工具  

    - jps： 虚拟机进程状况工具  

    - jstat： 虚拟机统计信息监视工具  

    - jinfo： Java配置信息工具  

      - 实时查看和调整虚拟机各项参数  

    - jmap： Java内存映像工具  

      - jmap（ Memory Map for Java） 命令用于生成堆转储快照（ 一般称为heapdump或dump文件）  

    - jhat： 虚拟机堆转储快照分析工具  

    - jstack： Java堆栈跟踪工具  

      ​		jstack（ Stack Trace for Java） 命令用于生成虚拟机当前时刻的线程快照（ 一般称为threaddump或者javacore文件） 。 线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合， 生成线程快照的目的通常是定位线程出现长时间停顿的原因， 如线程间死锁、 死循环、 请求外部资源导致的长时间挂起等， 都是导致线程长时间停顿的常见原因。 线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情， 或者等待着什么资源。  

  - 可视化故障处理工具  

  

## 第三部分 虚拟机执行子系统  

- 类文件结构  

  - 无关性的基石

    - jvm只与class文件关联，以jvm作为基础的其他语言，只要编译成class就可以了

  - **Class类文件的结构**：一组以8字节为基础单位的二进制流

    - 数据类型

      - 无符号数：基本数据类型
      - 表：由多个字符或者其他代表作为数据项构成 的复合数据

    - 常量池

      - 两大类常量
        - 字面值:（Literal）   
          - 文本字符串
          - final常量
        - 符号引用（Symbolic References）  
          - 被模块导出或者开放的包（Package）  
          - 字段的名称和描述符（Descriptor）  
          - 方法的名称和描述符  
          - 方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）  
          - 动态调用点和动态常量（Dynamically-Computed Call Site、 Dynamically-Computed Constant）  
      - 字段和方法都是虚拟机在运行的时候解释翻译到具体的内存地址中
      - 常量池中每一项常量都是一个表，总共有17中不同的类型
        - 常量池的17种数据类型的结构总表

    - 访问标志

      ​		在常量池结束之后， 紧接着的2个字节代表访问标志（access_flags） ， 这个标志用于识别一些类或者接口层次的访问信息， 包括： 这个Class是类还是接口； 是否定义为public类型； 是否定义为abstract类型； 如果是类的话， 是否被声明为final； 等等  

    - 类索引、 父类索引与接口索引集合  

    - 字段表集合：描述接口或者类中声明的变量

    - 方法表集合

    - 属性表集合

  - 字节码指令简介

    ​		指令由一个字节长度的、 代表着某种特定操作含义的数字（称为操作码， Opcode）
    以及跟随其后的零至多个代表此操作所需的参数（称为操作数， Operand） 构成。  

  - 公有设计，私有实现

  - Class文件结构的发展  

- **虚拟机类加载机制**  

  - 概述

  - 加载时机

    - 加载（Loading）  
    - 验证（Verification）  
    - 准备（Preparation） 
    - 解析（Resolution） 
    - 初始化（Initialization） 
      - 有且只有六种情况必须立即对类进行“初始化”（而加载、 验证、 准备自然需要在此之
        前开始）   
    - 使用（Using） 
    - 卸载（Unloading）  

    加载、 验证、 准备、 初始化和卸载这五个阶段的顺序是确定的  

  - 类加载的过程  

    - 加载

      - 通过一个类的全限定名来获取定义此类的二进制字节流。
      -  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
      - 在内存中生成一个代表这个类的java.lang.Class对象， 作为方法区这个类的各种数据的访问入
        口。  

    - 验证  

      - 文件格式验证、 元数据验证、 字节码验证和符号引用验证。  

    - 准备

      - 正式为类中定义的变量（即静态变量， 被static修饰的变量） 分配内存并设置类变量初
        始值的阶段 ，内存分配的仅包括**类变量**， 而不包括实例变量， 实例变量将会在对象实例化时随着对象一起分配在Java堆中。 其次是这里所说的初始值“通常情况”下是数据类型的零值   

    - 解析

      Java虚拟机将常量池内的符号引用替换为直接引用的过程  

      - 符号引用（Symbolic References） ： 符号引用以一组符号来描述所引用的目标， 符号可以是任何形式的字面量， 只要使用时能无歧义地定位到目标即可。  
      - 直接引用（Direct References） ： 直接引用是可以直接指向目标的指针、 相对偏移量或者是一个能间接定位到目标的句柄。  

    - 初始化：

      - 初始化阶段就是执行类构造器<clinit>()方法的过程 
        - 编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块） 中的语句合并产生的， 编译器收集的顺序是由语句在源文件中出现的顺序决定的， 静态语句块中只能访问到定义在静态语句块之前的变量， 定义在它之后的变量， 在前面的静态语句块可以赋值， 但是不能访问   

    - 使用

    - 卸载

  - 类加载器

    - 类与类加载器
      - 同一个类加载器加载的instanceof才为true

- 虚拟机字节码执行引擎  

  - 栈帧结构

    ​		“栈帧”（Stack Frame） 则是用于支持虚拟机进行方法调用和方法执行背后的数据结构， 它也是虚拟机运行时数据区中的虚拟机栈（Virtual MachineStack） [1]的栈元素。   

    - 局部变量表  
      - 超过作用域的局部变量内存可以被其他复用
      - 局部变量需要程序员初始化后使用
    - 操作数栈
    - 动态连接
    - 方法返回地址
    - 附加信息

  - 方法调用
    - 静态分派：所有依赖静态类型来决定方法执行版本的分派动作  ，发生在编译阶段
    - 动态分派：我们把这种在运行期根据实际类型确定方法执行版本的分派过程  
  - 动态类型语言支持
  - 基于栈的字节码解释执行引擎  

- 类加载及执行子系统的案例与实战  



## 第四部分 程序编译与代码优化  

- 前端编译与优化  
- 后端编译与优化  



## 第五部分 高效并发  

- 第12章 Java内存模型与线程  

  - 概述
  - 硬件的效率与一致性
    - 缓存一致性：多核处理器都有自己的高速缓存，公用一个主存，如何确保读写的一致性
    - jvm的即时编译器中也有指令重排序优化
  - java内存模型
    - 主内存与工作内存
      - 主内存：所有的变量都存储在主内存（Main Memory）   	
        - 主要对应于Java堆中的对象实例数据部分  
      - 工作内存：线程的工作内存中保存了被该线程使用的变量的主内存副本[2]， 线程对变量的所有操作（读取、 赋值等） 都必须在工作内存中进行， 而不能直接读写主内存中的数据  
        - 工作内存则对应于虚拟机栈中的部分区域。  
    - 内存间交互操作  
      - lock（锁定） ： 作用于主内存的变量， 它把一个变量标识为一条线程独占的状态。  
      - unlock（解锁） ： 作用于主内存的变量， 它把一个处于锁定状态的变量释放出来， 释放后的变量才可以被其他线程锁定。  
      - read（读取） ： 作用于主内存的变量， 它把一个变量的值从主内存传输到线程的工作内存中， 以便随后的load动作使用。  
      - load（载入） ： 作用于工作内存的变量， 它把read操作从主内存中得到的变量值放入工作内存的变量副本中。  
      - use（使用） ： 作用于工作内存的变量， 它把工作内存中一个变量的值传递给执行引擎， 每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。  
      - assign（赋值） ： 作用于工作内存的变量， 它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作  
      - store（存储） ： 作用于工作内存的变量， 它把工作内存中一个变量的值传送到主内存中， 以便随后的write操作使用。  
      - write（写入） ： 作用于主内存的变量， 它把store操作从工作内存中得到的变量的值放入主内存的变量中。  
    - 对于volatile型变量的特殊规则  
      - 两项特效
        - 第一项是保证此变量对所有线程的**可见性**， 这里的“可见性”是指当一条线程修改了这个变量的值， 新值对于其他线程来说是可以立即得知的。   
          - 由于volatile变量只能保证可见性， 在不符合以下两条规则的运算场景中， 我们仍然要通过加锁（使用synchronized、 java.util.concurrent中的锁或原子类） 来保证原子性  
            - 运算结果并不依赖变量的当前值， 或者能够确保只有单一的线程修改变量的值。  
            - 变量不需要与其他的状态变量共同参与不变约束。  
        - 第二个语义是禁止**指令重排序优化**， 普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果， 而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在同一个线程的方法执行过程中无法感知到这点， 这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics） 。 
    - 针对long和double型变量的特殊规则  
    - 原子性、 可见性与有序性  
      - 原子性
      - 可见性
      - 有序性
    - 先行发生原则  
  - java与线程
    - 状态转换：**6种线程状态**  
      - 新建（New） ： 创建后尚未启动的线程处于这种状态。
      - 运行（Runnable） ： 包括操作系统线程状态中的Running和Ready， 也就是处于此状态的线程有可能正在执行， 也有可能正在等待着操作系统为它分配执行时间。
      - 无限期等待（Waiting） ： 处于这种状态的线程不会被分配处理器执行时间， 它们要等待被其他线程显式唤醒。 以下方法会让线程陷入无限期的等待状态：
        -   没有设置Timeout参数的Object::wait()方法  
        - 没有设置Timeout参数的Thread::join()方法；  
        - LockSupport::park()方法。  
      - 限期等待（Timed Waiting） ： 处于这种状态的线程也不会被分配处理器执行时间， 不过无须等待被其他线程显式唤醒， 在一定时间之后它们会由系统自动唤醒。 以下方法会让线程进入限期等待状态： 
        -  Thread::sleep()方法；  
        - 设置了Timeout参数的Object::wait()方法；  
        - 设置了Timeout参数的Thread::join()方法；  
        - LockSupport::parkNanos()方法；  
        - LockSupport::parkUntil()方法  
      - 阻塞（Blocked） ： 线程被阻塞了， “阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁， 这个事件将在另外一个线程放弃这个锁的时候发生； 而“等待状态”则是在等待一段时间， 或者唤醒动作的发生。 在程序等待进入同步区域的时候， 线程将进入这种状态。
      - 结束（Terminated） ： 已终止线程的线程状态， 线程已经结束执行    
  - java与协程

- 第13章 线程安全与锁优化  

  - 线程安全

    - 不可变
    - 绝对线程安全
      -   
    - 相对线程安全
      - 相对线程安全就是我们通常意义上所讲的线程安全， 它需要保证对这个对象单次的操作是线程安
        全的， 我们在调用的时候不需要进行额外的保障措施， 但是对于一些特定顺序的连续调用， 就可能需要在调用端使用额外的同步手段来保证调用的正确性。   
      - 在Java语言中， 大部分声称线程安全的类都属于这种类型， 例如Vector、 HashTable、 Collections的synchronizedCollection()方法包装的集合等。
    - 线程兼容
    - 线程对立

  - 线程安全的是实现方法

    - 互斥同步  

      - synchronized  
      - 重入锁（ReentrantLock）   

      性能已经不再是选择synchronized或者ReentrantLock的决定因素  

    - 非阻塞同步  

      **CAS指令**需要有三个操作数， 分别是内存位置（在Java中可以简单地理解为变量的内存地址， 用V
      表示） 、 旧的预期值（用A表示） 和准备设置的新值（用B表示） 。 CAS指令执行时， 当且仅当V符合A时， 处理器才会用B更新V的值， 否则它就不执行更新。 但是， 不管是否更新了V的值， 都会返回V的旧值， 上述的处理过程是一个原子操作， 执行期间不会被其他线程中断。

      -  AtomicInteger  

      尽管CAS看起来很美好， 既简单又高效， 但显然这种操作无法涵盖互斥同步的所有使用场景， 并
      且CAS从语义上来说并不是真正完美的， 它存在一个逻辑漏洞： 如果一个变量V初次读取的时候是A
      值， 并且在准备赋值的时候检查到它仍然为A值， 那就能说明它的值没有被其他线程改变过了吗？ 这是不能的， 因为如果在这段期间它的值曾经被改成B， 后来又被改回为A， 那CAS操作就会误认为它从来没有被改变过。 这个漏洞称为CAS操作的“**ABA问题**”。   

    - 无同步方案

  - 锁优化

    - 自旋锁

