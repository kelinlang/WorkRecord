## 常用

- 树
  - 二叉树
    - 存储结构
      1. **typedef** **struct** BiTNode{
      2. ​    TElemType data;//数据域
      3. ​    **struct** BiTNode *lchild,*rchild;//左右孩子指针
      4. }BiTNode,*BiTree;
    - 遍历算法
      - 先序遍历：每遇到一个节点，先访问，然后再遍历其左右子树
      - 中序遍历：第一次经过时不访问，等遍历完左子树之后再访问，然后遍历右子树
      - 后序遍历：第一次和第二次经过时都不访问，等遍历完该节点的左右子树之后，最后访问该节点

- **查找算法**

  - 类型

    - 静态查找表：只查找
    - 动态查找表：查找，插入、删除

  - 算法

    静态查找表

    - 顺序查找算法

      - 从表中的最后一个数据元素开始，逐个同记录的关键字做比较，如果匹配成功，则查找成功；反之，如果直到表中第一个关键字查找完也没有成功匹配，则查找失败
      - 查找key存在顺序表的第一个位置，起**监视哨**的作用，从表最后一个元素一次遍历比较
      - 时间复杂度:平均查找长度 =  查找成功+查找失败
        - O(3(n+1)/4)

    - 拆半查找算法(二分查找)

      - 前提：静态查找表中的数据必须是有序的（需要对所查关键字进行排序）
      - 实现
        - 指针low和high分别指向第一个和最后一个关键字，mid指向中间位置
      - 性能
        - 查找过程用二叉判定树
      - 总结
        - 效率比顺序查找效率高，只适用于顺序存储的有序表，使用链式存储结构时，无法进行有效比较并且排序和查找都异常复杂

    - 分块查找算法：索引顺序查找

      - 实现
        - 分块有序
        - 子块内部关键字被查找概率相等可以随机存储，否则按被查概率降序排序，提高算法运行效率
        - 查索引表可以拆半查找算法，子块顺序查找
        - 查找流程
          - 确定关键字在哪个子块中
          - 顺序查找子块
      - 性能
        - 总体来说，分块查找算法的效率介于顺序查找和折半查找之间。

      总结：对特定关键字进行[顺序查找](http://data.biancheng.net/view/54.html)、[折半查找](http://data.biancheng.net/view/55.html)或者分块查找，都是在查找表中各关键字被查找概率相同的前提下进行的。在等概率的情况，使用折半查找算法的性能最优。

    - 静态树表查找算法

    动态查找表

    - 二叉排序树
      - 概念
        - 二叉排序树中，如果其根结点有左子树，那么左子树上所有结点的值都小于根结点的值；
        - 二叉排序树中，如果其根结点有右子树，那么右子树上所有结点的值都大小根结点的值；
        - 二叉排序树的左右子树也要求都是二叉排序树；
      - 过程
        - 首先同树的根结点进行比较
        - 如果相等，查找成功；
        - 如果比较结果为根结点的关键字值较大，则说明该关键字可能存在其左子树中；
        - 如果比较结果为根结点的关键字值较小，则说明该关键字可能存在其右子树中；
      - 插入关键字
        - 插入位置一定位于叶子结点，并且一定是查找失败时访问的最后一个结点的左孩子或右孩子
        - 通过使用二叉排序树对动态查找表做查找和插入的操作，同时在中序遍历二叉排序树时，可以得到有关所有关键字的一个有序的序列。
      - 删除关键字
        - 结点 p 为叶子结点，此时只需要删除该结点，并修改其双亲结点的指针即可；
        - 结点 p 只有左子树或者只有右子树，此时只需要将其左子树或者右子树直接变为结点 p 双亲结点的左子树即可；
        - 结点 p 左右子树都有，此时有两种处理方式：
          - 令结点 p 的左子树为其双亲结点的左子树；结点 p 的右子树为其自身直接前驱结点的右子树
          - 用结点 p 的直接前驱（或直接后继）来代替结点 p，同时在二叉排序树中对其直接前驱（或直接后继）做删除操作
      - 总结
        - 使用二叉排序树在查找表中做查找操作的[时间复杂度](http://data.biancheng.net/view/2.html)同建立的二叉树本身的结构有关。即使查找表中各数据元素完全相同，但是不同的排列顺序，构建出的二叉排序树大不相同。
        - 同深度有关
    - 平衡二叉树
      - 概念
        - 每棵子树中的左子树和右子树的深度差不能超过 1
        - 二叉树中每棵子树都要求是平衡二叉树；
        - 平衡因子：每个结点都有其各自的平衡因子，表示的就是其左子树深度同右子树深度的差
      - 二叉排序树转换平衡二叉树
        - 平衡二叉树的结构被破坏，此时只需要对二叉排序树做“旋转”操作
      - 总结
        - 使用平衡二叉树进行查找操作的[时间复杂度](http://data.biancheng.net/view/2.html)为`O(logn)`。在学习本节内容时，紧贴本节图示比较容易理解。
    -  [红黑树算法(更高级的二叉查找树)](http://data.biancheng.net/view/vip_254.html)
      - 概念:红黑树并不是[平衡二叉树](http://data.biancheng.net/view/59.html)
        - 树中的每个结点增加了一个用于存储颜色的标志域；
        - 中没有一条路径比其他任何路径长出两倍，整棵树要接近于“平衡”的状态。
      - 总结
        - 红黑树，虽隶属于二叉查找树，但是二叉查找树的时间复杂度会受到其树深度的影响，而红黑树可以保证在最坏情况下的时间复杂度仍为`O(lgn)`。当数据量多到一定程度时，使用红黑树比二叉查找树的效率要高。
    - [B-树及其基本操作](http://data.biancheng.net/view/vip_255.html)
    -  [B+树及插入和删除操作](http://data.biancheng.net/view/vip_256.html)
    - [键树查找法（双链树和字典树）](http://data.biancheng.net/view/vip_257.html)
    - [什么是哈希表（散列表）](http://data.biancheng.net/view/63.html)
      - 常用哈希函数
        - 直接定址法
        - 数字分析法
        - 平方取中法
        - 折叠法
        - 除留余数法
        - 随机数法
      - 处理冲突的方法
        - 开放定址法
        - 再哈希法
        - 链地址法
        - 建立一个公共溢出区
    - [哈希查找算法](http://data.biancheng.net/view/vip_258.html)

- 排序算法
  - 插入排序算法
    - 概念
      - 将数据按照一定的顺序一个一个的插入到有序的表中
    - 种类
      - 直接插入排序
        - 概念
          - 采用的方法是：在添加新的记录时，使用[顺序查找](http://data.biancheng.net/view/54.html)的方式找到其要插入的位置，然后将新记录插入。
        - 性能
          - O(n2)
      - 折半插入排序
        - 前提
          - 表中数据本身有序
        - 概念
          - [折半查找](http://data.biancheng.net/view/55.html)来代替顺序查找
        - 性能
          - 折半插入排序算法相比较于直接插入排序算法，只是减少了关键字间的比较次数，而记录的移动次数没有进行优化，所以该算法的[时间复杂度](http://data.biancheng.net/view/2.html)仍是 `O(n2)`。
      - 2-路插入排序
        - 概念
          - 折半插入排序的基础上对其进行改进，减少其在排序过程中移动记录的次数从而提高效率
        - 实现
          - 另外设置一个同存储记录的[数组](http://data.biancheng.net/view/181.html)大小相同的数组 d，将无序表中第一个记录添加进 d[0] 的位置上，然后从无序表中第二个记录开始，同 d[0] 作比较：如果该值比 d[0] 大，则添加到其右侧；反之添加到其左侧。
        - 性能
          - 2-路插入排序相比于折半插入排序，只是减少了移动记录的次数，没有根本上避免，所以其[时间复杂度](http://data.biancheng.net/view/2.html)仍为`O(n2)`。
      - 表插入排序
        - 概念
          - 链表存储
        - 性能
          - 从表插入排序的实现过程上分析，与直接插入排序相比只是避免了移动记录的过程（修改各记录结点中的指针域即可），而插入过程中同其它关键字的比较次数并没有改变，所以表插入排序算法的[时间复杂度](http://data.biancheng.net/view/2.html)仍是`O(n2)`。
      - 希尔排序
    - 起泡排序，别名“冒泡排序”
      - 概念
        - 该算法的核心思想是将无序表中的所有记录，通过两两比较关键字，得出升序序列或者降序序列。
      - 性能
        - 该算法的时间复杂度为`O(n2)`。
    - 快速排序算法
      - 概念
        - 通过一次排序将整个无序表分成相互独立的两部分，其中一部分中的数据都比另一部分中包含的数据的值小，然后继续沿用此方法分别对两部分进行同样的操作，直到每一个小部分不可再分，所得到的整个序列就成为了有序序列。
      - 性能
        - 快速排序算法的[时间复杂度](http://data.biancheng.net/view/2.html)为`O(nlogn)`，是所有时间复杂度相同的排序方法中性能最好的排序算法。
  - 选择排序算法
    - 简单选择排序
    - [树](http://data.biancheng.net/view/23.html)形选择排序
    - 堆排序

